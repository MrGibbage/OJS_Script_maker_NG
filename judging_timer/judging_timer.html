<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Judging Day Scheduler & Timer</title>
  <link rel="manifest" href="./manifest.json">
  <meta name="theme-color" content="#071025">
  <style>
    :root{
      --scale: 1.5;
      --bg-top: #071025;
      --bg-bottom: #071a2d;
      --card: rgba(255,255,255,0.02);
      --muted:#9aa6bb;
      --accent:#ffb86b;
      --good:#20c997;
      --warn:#ffb86l;
      --bad:#ef476f;
      --text:#e6eef8;
      font-family: Inter, "Segoe UI", Roboto, system-ui, -apple-system, "Helvetica Neue", Arial;
    }
    /* Light theme variable overrides when .light-theme is present on <html> */
    .light-theme{
      --bg-top: #f6f8fb;
      --bg-bottom: #eef4fb;
      --card: rgba(0,0,0,0.04);
      --muted: #6b7280;
      --text: #071225;
      --accent: #ffb86l;
      --good: #17c964;
      --bad: #c2243b;
    }
    html,body{height:100%;margin:0;background: linear-gradient(180deg,var(--bg-top),var(--bg-bottom));color:var(--text)}
    /* prevent page scrolling entirely (content must fit inside) */
    html, body { overflow: hidden; }
    /* FIX: prevent judging card from overflowing the viewport */
    html, body { overflow-x: hidden; }
    .wrap {
      /* ensure wrap never exceeds viewport and includes padding in its width */
      max-width: calc(100vw - 24px) !important;
      width: 100% !important;
      box-sizing: border-box !important;
      margin: 0 auto !important;
      padding-left: 12px !important;
      padding-right: 12px !important;
    }
    #judgingView {
      max-width: 100% !important;
      box-sizing: border-box !important;
      overflow: hidden !important;
    }
    #judgingHeader {
      /* allow header to wrap instead of forcing horizontal scroll */
      flex-wrap: wrap !important;
      align-items: flex-start !important;
    }
    #judgingHeader > div:first-child{ min-width:0 !important; flex: 1 1 auto !important; }
    #judgingHeader .timers{ flex-shrink: 0 !important; min-width: 110px !important; max-width: 45% !important; box-sizing: border-box !important; }
    @media (max-width:600px){
      .wrap{ max-width: calc(100vw - 16px) !important; padding-left:8px !important; padding-right:8px !important; }
      #judgingHeader .timers{ width:100% !important; max-width:100% !important; min-width:0 !important; margin-top:8px !important; }
    }

    .outer{display:flex;justify-content:center;align-items:flex-start;padding:18px;min-height:100vh;box-sizing:border-box}
    .wrap{
      width: 100%;
      max-width: 1200px;
      padding:26px;border-radius:12px;background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      box-shadow: 0 6px 30px rgba(2,6,23,0.6);box-sizing:border-box;
    }

    header{display:flex;align-items:center;justify-content:space-between;gap:22px;flex-wrap:wrap}
    .header-left{display:flex;align-items:center;gap:12px;min-width:0}
    #logo{height:40px;width:auto;border-radius:6px;opacity:0.98;box-shadow:0 1px 6px rgba(0,0,0,0.35)}
    .left{display:flex;flex-direction:column;min-width:0}
    .local-time{font-size:16px;color:var(--muted);white-space:nowrap;}
    .elapsed{margin-top:6px;font-weight:700;font-size:28px;display:flex;gap:12px;align-items:center;white-space:nowrap}
    .controls{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    button{background:var(--card);color:var(--text);border:1px solid rgba(255,255,255,0.04);padding:10px 14px;border-radius:8px;cursor:pointer;font-weight:600;white-space:nowrap}
    button.primary{background: linear-gradient(90deg,var(--accent), #ff9f43);color:#061220;border:none}
    button.danger{background: rgba(239,71,111,0.08);color:var(--bad);border:1px solid rgba(239,71,111,0.14)}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04)}

    /* Disabled state styling: make disabled buttons appear grayed out and non-interactive */
    button[disabled], button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      pointer-events: none;
      filter: grayscale(25%);
    }

    /* Make the bottom-bar Start Now button clearly look disabled when disabled */
    #bbStartNow[disabled].primary {
      background: var(--card);
      color: var(--muted);
      border: 1px solid rgba(255,255,255,0.04);
      box-shadow: none;
    }
    #bbStartNow[disabled].danger {
      background: rgba(239,71,111,0.03);
      color: rgba(239,71,111,0.6);
      border-color: rgba(239,71,111,0.06);
      box-shadow: none;
    }

    /* Make the bottom-bar Edit button clearly look disabled when disabled */
    #bbEdit[disabled] {
      background: var(--card) !important;
      color: var(--muted) !important;
      border: 1px solid rgba(255,255,255,0.04) !important;
      box-shadow: none !important;
      opacity: 0.5 !important;
      cursor: not-allowed !important;
      pointer-events: none !important;
      filter: grayscale(25%) !important;
    }

    main{margin-top:84px}
    .small{font-size:13px;color:var(--muted);margin-bottom:10px}

    #idleView{display:none;padding:18px;border-radius:10px;background:rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.02)}
    #idleView .big{font-size:72px;line-height:1;color:var(--text);margin-top:6px}
    /* Ensure idle clock element is always visible and styled */
    #idleClock{ display:block; color:var(--text); font-variant-numeric: tabular-nums; }

    /* Large persistent local time displayed while idle. Fixed so it remains visible between header and bottom bar */
    #localTime{
      position: fixed;
      top: 84px; /* below header */
      left: 50%;
      transform: translateX(-50%);
      z-index: 1500; /* below header (1600) but above main content */
      font-weight: 800;
      color: var(--text);
      font-variant-numeric: tabular-nums;
      text-align: center;
      padding: 6px 12px;
      border-radius: 10px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      box-shadow: 0 6px 20px rgba(0,0,0,0.35);
      pointer-events: none; /* decorative only */
      font-size: calc(28px * var(--scale));
      line-height: 1;
      white-space: nowrap;
    }
    /* Override: make the large localTime about 4x bigger without changing layout flow */
    #localTime {
      font-size: calc(28px * var(--scale) * 4) !important; /* ~168px when --scale is 1.5 */
    }
    @media (max-width:800px){
      #localTime { font-size: calc(22px * var(--scale) * 4) !important; }
    }
    @media (max-width:480px){
      #localTime { font-size: calc(18px * var(--scale) * 4) !important; }
    }

    #judgingView{display:none;padding:18px;border-radius:10px;background:rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.02)}
    /* New judging header grid layout */
    #judgingHeader{
      display: grid !important;
      grid-template-columns: 1fr auto;
      gap: 12px;
      align-items: start; /* top-justify both columns */
      width: 100%;
      box-sizing: border-box;
      padding: 12px 6px;
    }
    #judgingHeader .team-wrap{ min-width:0; }
    #judgingHeader .team{
      font-size: 26px; /* slightly bigger */
      font-weight: 900;
      white-space: normal; /* allow wrapping */
      overflow-wrap: break-word;
      word-break: break-word;
      color: var(--text);
    }
    #judgingHeader .timers{ display:flex; flex-direction:column; align-items:flex-end; min-width:90px; }
    #judgingHeader .timers .big, #judgingHeader .timers .elapsed{
      font-size: 36px; /* larger elapsed display */
      font-weight:900;
      line-height: 1;
    }
    @media (max-width:600px){
      #judgingHeader{ grid-template-columns: 1fr; }
      #judgingHeader .timers{ align-items:flex-start; margin-top:8px; }
      #judgingHeader .team{ font-size:22px; }
      #judgingHeader .timers .big{ font-size:28px; }
    }
    #judgingHeader .team{font-size:22px;font-weight:800}
    #judgingHeader .timers{display:flex;flex-direction:column;align-items:flex-end}
    #judgingHeader .timers .big{font-size:30px;font-weight:800}
    .segments{margin-top:12px;display:flex;flex-direction:column;gap:8px;padding-right:12px}
    .segment{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;border-radius:8px;background:rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.02);gap:12px}
    .segment .seg-title{flex:1 1 auto;margin-right:12px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
    .seg-status{flex:0 0 auto;min-width:72px;text-align:right;font-weight:700;font-size:14px}
    .seg-status.done{color:var(--good)}
    .seg-status.current{color:var(--warn)}
    .seg-status.upcoming{color:var(--muted)}

    /* Style for active segment: make left title and right timer yellow, and double the timer digits */
    .segment.current .seg-title { color: #FFD54F !important; }
    .segment.current .seg-status { color: #FFD54F !important; font-size: 28px !important; }

    /* Light-theme: use a darker orange for active segment so it stands out on light backgrounds */
    .light-theme .segment.current .seg-title { color: #D97706 !important; }
    .light-theme .segment.current .seg-status { color: #D97706 !important; font-size: 28px !important; }

    .editor{display:none;margin-top:8px;border-radius:10px;padding:14px;background: rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.02)}
    .editor .row{display:flex;align-items:center;gap:10px;padding:8px 0}
    .editor label{display:block;font-size:13px;color:var(--muted);margin-bottom:6px}
    .editor input[type="text"]{flex:1;padding:8px 10px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:rgba(0,0,0,0.12);color:var(--text)}
    .editor input[type="time"]{padding:8px 10px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:rgba(0,0,0,0.12);color:var(--text)}
    .editor .hint{font-size:13px;color:var(--muted);margin-top:8px}
    .error{color:var(--bad);font-weight:700;margin-top:8px}
    .warning{color:var(--accent);font-weight:700;margin-top:8px}
    .conflict{border:2px solid rgba(239,71,111,0.22);box-shadow:0 0 0 3px rgba(239,71,111,0.04) inset}

    footer{margin-top:18px;color:var(--muted);font-size:13px}

    @media (max-width:800px){ :root { --scale: 1.2; } }
    @media (max-width:480px){ :root { --scale: 1.0; } .segments{gap:6px} .segment{padding:8px} }

    button:focus,input:focus{outline:2px solid rgba(255,255,255,0.06);outline-offset:2px}

    /* Layout overrides: fixed header, full-width content, inline hamburger */
    /* fixed header: explicit height to compute available space */
    header{ position:fixed; top:0; left:0; right:0; height:64px; display:flex; align-items:center; background: linear-gradient(180deg, rgba(7,16,37,0.95), rgba(7,22,45,0.75)); padding:12px 18px; box-sizing:border-box; z-index:1600; }
    #menuToggle{ position:static !important; }
    /* wrap occupies remaining vertical space between header and bottomBar; internal scrolling if needed */
    .wrap{ transform: none !important; width:100%; /* slightly smaller than viewport to avoid 1-2px horizontal scroll */ max-width:calc(100vw - 6px); box-sizing:border-box; padding:12px 18px; padding-right:18px; margin:0; height: calc(100vh - 64px - 64px); overflow:hidden; border-radius:0; }
    /* ensure views use full available width inside wrap */
    #idleView, #judgingView, .editor{ width:100%; }

    .hamburger{width:36px;height:36px;border-radius:8px;display:inline-flex;align-items:center;justify-content:center;cursor:pointer}
    .hamburger .bar{width:18px;height:2px;background:var(--text);border-radius:2px;position:relative}
    .hamburger .bar:before,.hamburger .bar:after{content:'';position:absolute;left:0;width:18px;height:2px;background:var(--text);border-radius:2px}
    .hamburger .bar:before{top:-6px}
    .hamburger .bar:after{top:6px}

    /* pin hamburger to top-left inside header */
    #menuToggle{ position:relative; left:auto; top:auto; z-index:1500; width:42px; height:42px; display:flex; align-items:center; justify-content:center; border-radius:8px; background: rgba(0,0,0,0.06); }
    #menuToggle .bar{ width:18px; height:2px; background:var(--text); border-radius:2px; }
    /* Judging header/timers layout tweaks: prevent clipping of large timers and allow segments to expand */
    #judgingHeader .timers{ flex: 0 0 auto; padding-left:12px; display:flex; flex-direction:column; align-items:flex-end; min-width:120px; }
    #judgingHeader .timers .big{ overflow:visible; white-space:nowrap; font-size:44px; text-align:right; }
    /* allow inner judging header containers to show overflow if needed */
    #judgingView > div { overflow-x: visible !important; }
    /* ensure segments area can grow and not be clipped */
    .segments{ flex:1; min-width:0; }
    .segment{ overflow:visible; }
    /* Prevent overall elapsed timer from being clipped: align header to top and increase timer line-height */
    #judgingHeader{ align-items:flex-start; padding-top:6px; }
    #judgingHeader .timers .big{ font-size:44px !important; line-height: 1 !important; overflow:visible !important; }
    /* Team takes remaining space to the left of the timers; allow long names to truncate with ellipsis */
    #judgingHeader .team{ flex: 1 1 auto; min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }

    /* bottom action bar: fixed height to compute available space */
    #bottomBar{ height:64px; padding:8px 18px; box-sizing:border-box; z-index:9999; pointer-events:auto; }
    #bbStartNow{ z-index:10000; pointer-events:auto; touch-action:manipulation; }

    /* FORCE full-width content: remove centering and left-indent so main views span viewport */
    .outer{ justify-content:flex-start; padding:0; }
    /* ensure section inner containers stretch to available wrap width */
    #idleView > div, #judgingView > div, main { width: 100%; max-width: 100%; box-sizing: border-box; overflow-x: hidden; }
    .wrap { overflow-x: hidden; }
    /* Ensure main content is pushed below the fixed header so idle card is visible */
    .wrap{ padding-top:84px !important; }
    #idleView{ margin-top:6px; }
    @media (max-width:480px){ #idleView .big{ font-size:40px; } }

    /* Theme app menu panel and its menu items to stand out from page */
    #appMenu{
      position: fixed !important;
      top: 64px !important; /* align just below the header */
      left: 0 !important;
      right: 0 !important;
      bottom: 0 !important;
      width: 100% !important;
      height: calc(100vh - 64px) !important;
      z-index: 1550 !important; /* below header (1600) so header remains on top */
      overflow: auto !important; /* allow scrolling within the panel */
      padding: 18px !important;
      box-sizing: border-box !important;
      margin: 0 !important;
      border-radius: 0 !important;
      /* Nearly-opaque dark panel (slightly lighter than the page background) for dark mode */
      background-color: rgba(8,16,28,0.96) !important;
      border: 1px solid rgba(255,255,255,0.04) !important;
      color: var(--text) !important;
      box-shadow: 0 14px 40px rgba(0,0,0,0.6) !important;
    }
    /* Light-theme: nearly-opaque light panel (slightly darker than page in light mode) */
    .light-theme #appMenu{
      background-color: rgba(255,255,255,0.96) !important;
      border: 1px solid rgba(0,0,0,0.06) !important;
      color: var(--text) !important;
    }
    #appMenu .menu-row{ padding:6px 4px; border-radius:8px; }
    #appMenu .menu-row + .menu-row{ margin-top:8px; }

    /* Make menu buttons look like tactile controls */
    #appMenu button.menu-btn, #appMenu .menu-row button, #appMenu .menu-row .menu-btn{
      display:block; width:100%; text-align:left; padding:10px 12px; border-radius:8px;
      background: rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.06); color:var(--text); font-weight:700; cursor:pointer;
    }
    #appMenu button.menu-btn:hover, #appMenu .menu-row button:hover{ background: rgba(255,255,255,0.035); border-color: rgba(255,255,255,0.14); }
    #appMenu button.menu-btn:focus, #appMenu .menu-row button:focus{ outline:2px solid rgba(255,255,255,0.08); outline-offset:2px }

    /* Tweak label rows and danger actions */
    #appMenu label{ display:flex; align-items:center; justify-content:space-between; padding:10px 8px; background: rgba(255,255,255,0.01); border-radius:8px; border:1px solid rgba(255,255,255,0.02); }
    #appMenu .menu-row .danger{ background: rgba(239,71,111,0.06); border-color: rgba(239,71,111,0.12); color: var(--bad); }

    /* Light-theme overrides for header and bottom bar to match light mode */
    .light-theme header{
      background: linear-gradient(180deg, rgba(255,255,255,0.95), rgba(245,249,253,0.9));
      box-shadow: 0 2px 10px rgba(2,6,23,0.06);
      color: var(--text);
    }
    .light-theme #bottomBar{
      background: linear-gradient(180deg, rgba(0,0,0,0.03), rgba(0,0,0,0.06));
    }
    .light-theme #menuToggle{ background: rgba(0,0,0,0.04); }

    /* DEBUG: temporary visible border around the judging card removed */
    /* (removed debug border and box-shadow) */

    /* Legacy judging header CSS removed — neutralize any remaining selectors and provide placeholder styling */
    #judgingHeader,
    #judgingHeader > div:first-child,
    #judgingHeader .timers,
    #judgingHeader .timers .big,
    #judgingHeader .team {
      /* intentionally neutralized because the old header was removed */
      all: unset !important;
      display: block !important;
      box-sizing: border-box !important;
      margin: 0 !important;
      padding: 0 !important;
      border: none !important;
      background: transparent !important;
      color: inherit !important;
    }

    /* TEMP DEBUG: outline team and timer cells to verify same-row layout */
    #judgingHeader .team-wrap {
      outline: 2px solid orange !important;
      outline-offset: 3px;
    }
    #judgingHeader .timers {
      outline: 2px solid deepskyblue !important;
      outline-offset: 3px;
    }

    /* Restore proper judging header layout (overrides any neutralizing rules) */
    #judgingHeader {
      display: grid !important;
      grid-template-columns: 1fr auto !important;
      gap: 12px !important;
      align-items: start !important;
      width: 100% !important;
      box-sizing: border-box !important;
    }
    #judgingHeader .team-wrap { display: block !important; min-width: 0 !important; }
    #judgingHeader .team { display: block !important; font-size: 26px !important; font-weight: 900 !important; white-space: normal !important; overflow-wrap: break-word !important; }
    /* Make the timers column only as wide as its content */
    #judgingHeader .timers {
      display: flex !important;
      flex-direction: column !important;
      align-items: flex-end !important;
      min-width: 0 !important;
      width: auto !important;
      justify-self: end !important;
      align-self: start !important;
      box-sizing: border-box !important;
    }
    #judgingHeader .timers .big, #judgingHeader .timers .elapsed { white-space: nowrap !important; }
    /* Final adjustments: remove debug outlines and match timer digits to team font */
    #judgingHeader .team-wrap,
    #judgingHeader .timers {
      outline: none !important;
      outline-offset: 0 !important;
    }
    #judgingHeader .team {
      font-size: 26px !important;
      font-weight: 900 !important;
      line-height: 1.05 !important;
    }
    #judgingHeader .timers .big,
    #judgingHeader .timers .elapsed {
      font-size: 26px !important;
      font-weight: 900 !important;
      line-height: 1.05 !important;
      white-space: nowrap !important;
    }
  </style>
</head>
<body>
  <div class="outer">
    <div class="wrap" role="application" aria-label="Judging day scheduler">

      <header style="width:100%;display:flex;align-items:center;justify-content:space-between;gap:12px;">
        <div style="display:flex;align-items:center;gap:8px;">
          <button id="menuToggle" class="hamburger" aria-label="Open menu" title="Open menu"><span class="bar"></span></button>
        </div>
        <div id="headerTitle" style="flex:1;text-align:center;font-weight:800;font-size:18px;color:var(--text)">VA-DC FLL Judging Timer</div>
        <div style="display:flex;align-items:center;justify-content:flex-end;gap:12px;">
          <img id="logo" src="./assets/logo.png" alt="FIRST FLL VA/DC logo" style="height:40px;width:auto;border-radius:6px;opacity:0.98;box-shadow:0 1px 6px rgba(0,0,0,0.35)" />
        </div>
      </header>

      <div id="bottomBar" style="position:fixed;left:0;right:0;bottom:0;display:flex;gap:8px;padding:10px;background:linear-gradient(180deg,rgba(0,0,0,0.02),rgba(0,0,0,0.04));justify-content:center;z-index:1400"> 
        <button id="bbStartNow" class="primary" style="flex:1;padding:14px 18px;font-size:16px;border-radius:10px;" onclick="handleBbStartNow && handleBbStartNow(event)">Start Now</button>
        <button id="bbEdit" class="ghost" style="flex:1;padding:14px 18px;font-size:16px;border-radius:10px;">Edit</button>
      </div>

      <main>
        <!-- large persistent local time (fixed) - moved here so it's always rendered -->
        <div id="localTime" aria-hidden="false">00:00</div>
        <div class="small" aria-hidden="true" style="color:transparent">&nbsp;</div>

        <section id="idleView" aria-live="polite">
          <div style="display:flex;align-items:center;justify-content:space-between;gap:10px">
            <div>
              <div style="font-size:18px;color:var(--muted)">Waiting for next team</div>
              <div class="sub" id="idleSub">No events scheduled</div>
            </div>
            <div style="text-align:right; margin-right:24px; min-width:0">
              <div class="big" id="idleClock">00:00</div>
              <div class="sub" id="idleTimeNow" style="margin-top:6px;color:var(--muted)"></div>
            </div>
          </div>
        </section>

        <section id="judgingView" aria-live="polite">
          <!-- New judging header: two-column grid (team | elapsed timer) -->
          <div id="judgingHeader" role="region" aria-label="Judging header" class="judging-header">
            <div class="team-wrap">
              <div class="team" id="judgingTeam">Team Name</div>
              <div class="slot" id="judgingSlot" style="font-size:13px;color:var(--muted);margin-top:6px">Slot</div>
            </div>
            <div class="timers" aria-hidden="false">
              <div class="big elapsed" id="judgingElapsed">00:00</div>
              <div class="elapsed-label" style="font-size:13px;color:var(--muted);margin-top:6px">Judging elapsed</div>
            </div>
          </div>

           <div class="segments" id="segmentsList"></div>
         </section>

        <section class="editor" id="editorView" aria-live="polite">
          <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px">
            <div style="font-weight:800">Day Schedule Editor (up to 7 teams)</div>
            <div style="font-size:13px;color:var(--muted)">Saved to local storage</div>
          </div>

          <div id="editorRows"></div>

          <div style="display:flex;gap:10px;margin-top:12px">
            <button id="saveDayBtn" class="primary">Save Day Schedule</button>
            <button id="cancelDayBtn" class="ghost">Cancel</button>
            <button id="clearDayBtn" class="danger">Clear All</button>
          </div>

          <div id="editorError" class="error" style="display:none"></div>
          <div id="editorWarn" class="warning" style="display:none"></div>

          <div class="hint">Rules: Judging sessions are 30 minutes. The editor will reject schedules whose 30-minute judging windows overlap. A 15-minute discussion after each judging is allowed but if it overlaps the next judging you'll receive a warning.</div>
        </section>

        <div id="appMenu">
          <h4>Judging Day Menu</h4>
          <div class="menu-row"><button id="themeToggleBtn2" class="ghost menu-btn" title="Toggle light/dark mode" aria-pressed="false">Theme</button></div>
          <div class="menu-row"><button id="helpBtn" class="ghost" title="Help & information">Help</button></div>
        </div>

        <div id="helpModal" style="display:none;" aria-hidden="true"><div class="modal"><h3>Judging Day Scheduler</h3><p>Welcome to the Judging Day Scheduler & Timer. This tool helps you manage judging sessions and breaks efficiently.</p><p><strong>Key Features:</strong></p><ul><li>View and edit the judging schedule for the day.</li><li>Start, pause, and resume judging sessions with ease.</li><li>Receive alerts when it's time to switch teams or start discussions.</li><li>Clear and fill example schedules for quick setup.</li></ul><p>For detailed instructions, refer to the <a href="https://va-dcfll.org" target="_blank" rel="noopener noreferrer">official guide</a>.</p><button id="closeHelpBtn" class="primary" style="margin-top:12px">Got it, thanks!</button></div></div>

        <footer>Built for VA-DC FLL Judges.</footer>
      </main>
    </div>
  </div>

  <script>
// Minimal stable app script to avoid runtime syntax errors. Rest of features can be restored incrementally.
const MAX_TEAMS = 7;
const JUDGING_MIN = 30;
const DISCUSSION_MIN = 15;
const STORAGE_KEY = 'judgingDaySchedule_v2';

const localTimeEl = document.getElementById('localTime');
const idleView = document.getElementById('idleView');
const idleClock = document.getElementById('idleClock');
const idleSub = document.getElementById('idleSub');
const idleTimeNow = document.getElementById('idleTimeNow');
const startNowBtn = document.getElementById('startNowBtn');
const bbStartNow = document.getElementById('bbStartNow');
const bbEdit = document.getElementById('bbEdit');
const editorView = document.getElementById('editorView');
const editorRows = document.getElementById('editorRows');
// add judging view references
const judgingView = document.getElementById('judgingView');
const judgingTeam = document.getElementById('judgingTeam');
const judgingSlot = document.getElementById('judgingSlot');
const judgingElapsed = document.getElementById('judgingElapsed');
const segmentsList = document.getElementById('segmentsList');
// add missing DOM buttons
const openEditorBtn = document.getElementById('openEditorBtn');
const idleEditBtn = document.getElementById('idleEditBtn');
const saveDayBtn = document.getElementById('saveDayBtn');
const cancelDayBtn = document.getElementById('cancelDayBtn');
const clearDayBtn = document.getElementById('clearDayBtn');

let manualSession = null;
let intervalId = null;
// currently active scheduled/manual judging session (null when idle)
let activeJudging = null;
// prevent reentrant bottom-bar handler calls
let bbHandling = false;
// slots cancelled during this runtime (prevents re-appearing immediately)
const cancelledSlots = new Set();
// whether there is any non-cancelled scheduled entry (demo or saved)
let hasSavedActiveSchedule = false;

function setBottomBarState(isJudging){
  if(!bbStartNow) return;
  if(isJudging){
    bbStartNow.textContent = 'End / Cancel';
    bbStartNow.classList.remove('primary');
    bbStartNow.classList.add('danger');
    bbStartNow.title = 'End current judging';
  } else {
    bbStartNow.textContent = 'Start Now';
    bbStartNow.classList.remove('danger');
    bbStartNow.classList.add('primary');
    bbStartNow.title = 'Start a manual judging session';
  }

  // Disable the bottom-bar Edit button while judging is active; enable when idle
  // Ensure edit button reflects judging/editor state
  updateEditButtonState(isJudging);
}

// Helper: enable/disable the bottom-bar Edit button based on judging state and editor visibility
function updateEditButtonState(isJudging){
  if(!bbEdit) return;
  // correctly detect whether the editor view is currently visible
  const inEditor = !!(editorView && editorView.style && editorView.style.display && editorView.style.display !== 'none');
  const shouldDisable = !!isJudging || !!inEditor;
  bbEdit.disabled = shouldDisable;
  if(shouldDisable) bbEdit.classList.add('disabled'); else bbEdit.classList.remove('disabled');

  // Additionally: when the editor is open, disable the bottom-bar "Start Now" button
  if(bbStartNow){
    bbStartNow.disabled = !!inEditor;
  }
  if(typeof startNowBtn !== 'undefined' && startNowBtn){
    startNowBtn.disabled = !!inEditor;
  }
}

// Observe editor visibility changes and update the edit button accordingly
if(window.MutationObserver && editorView){
  try{
    const mo = new MutationObserver(()=>{
      // when editor visibility changes, update the button (preserve current judging state from bbStartNow class)
      const isJudging = bbStartNow && bbStartNow.classList.contains('danger');
      updateEditButtonState(isJudging);
    });
    mo.observe(editorView, { attributes: true, attributeFilter: ['style'] });
  }catch(e){ /* noop */ }
}

function pad2(n){ return String(n).padStart(2,'0'); }
function fmtMS(sec){ if(sec<0) sec=0; const m=Math.floor(sec/60); const s=Math.floor(sec%60); return m+':'+String(s).padStart(2,'0'); }

function tickLocalTime(){
  const now = new Date();
  const opts = { hour:'numeric', minute:'2-digit', hour12:true };
  const formatted = now.toLocaleTimeString([], opts).replace(/\s+/, '');
  if(localTimeEl) localTimeEl.textContent = formatted; // show large clock text only
  if(idleTimeNow) idleTimeNow.textContent = 'Now: ' + formatted;
}

function loadDaySchedule(){ try{ return JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]'); }catch(e){ return []; } }
function saveDaySchedule(schedule){ localStorage.setItem(STORAGE_KEY, JSON.stringify(schedule)); }

function computeDatesForSchedule(schedule, today=new Date()){
  return (schedule||[]).map(entry=>{
    // If this slot was cancelled during this runtime, treat it as not scheduled
    if(entry && typeof entry.slot === 'number' && cancelledSlots.has(entry.slot)){
      return { ...entry, startDate: null, judgingEnd: null, discussionEnd: null };
    }
    let startDate = null;
    if(entry && entry.startTime && /^\d{2}:\d{2}$/.test(entry.startTime)){
      const [hh,mm] = entry.startTime.split(':').map(Number);
      startDate = new Date(today.getFullYear(), today.getMonth(), today.getDate(), hh, mm, 0, 0);
    }
    // allow per-entry millisecond overrides (used by demo)
    const judgingMs = entry && entry.judgingMs ? entry.judgingMs : JUDGING_MIN*60*1000;
    const discussionMs = entry && entry.discussionMs ? entry.discussionMs : DISCUSSION_MIN*60*1000;
    let judgingEnd = startDate ? new Date(startDate.getTime() + judgingMs) : null;
    let discussionEnd = judgingEnd ? new Date(judgingEnd.getTime() + discussionMs) : null;
    return { ...entry, startDate, judgingEnd, discussionEnd };
  }).sort((a,b)=>{
    if(!a.startDate && !b.startDate) return (a.slot||0)-(b.slot||0);
    if(!a.startDate) return 1;
    if(!b.startDate) return -1;
    return a.startDate.getTime() - b.startDate.getTime();
  });
}

// Default segment definitions (minutes)
const DEFAULT_SEGMENTS = [
  { title: 'Introduction', minutes: 2 },
  { title: 'Innovation Project Presentation', minutes: 5 },
  { title: 'Innovation Project Q & A', minutes: 5 },
  { title: 'Robot Design Presentation', minutes: 5 },
  { title: 'Robot Design Q & A', minutes: 5 },
  { title: 'Feedback', minutes: 8 }
];

// Build segment objects for a schedule entry. Supports minutes (production) and seconds (demo).
function getSegmentsForEntry(entry){
  if(!entry) return [];
  // explicit segments provided
  if(entry.segments && Array.isArray(entry.segments) && entry.segments.length){
    // demo-style seconds segments
    if(entry.segmentsSeconds){
      const segs = entry.segments.map(s=>({ title: s.title, seconds: s.seconds }));
      if(entry.startDate){
        let cursor = new Date(entry.startDate.getTime());
        for(const s of segs){ s.start = new Date(cursor.getTime()); s.end = new Date(cursor.getTime() + (s.seconds||0)*1000); cursor = new Date(s.end.getTime()); }
      }
      return segs;
    }
    // standard minute-based segments
    const segs = entry.segments.map(s=>({ title: s.title, minutes: s.minutes }));
    if(entry.startDate){
      let cursor = new Date(entry.startDate.getTime());
      for(const s of segs){ s.start = new Date(cursor.getTime()); s.end = new Date(cursor.getTime() + (s.minutes||0)*60*1000); cursor = new Date(s.end.getTime()); }
    }
    return segs;
  }

  // No explicit segments: use defaults. If entry.judgingMs present (demo) treat defaults as seconds
  if(entry && entry.judgingMs){
    const segs = DEFAULT_SEGMENTS.map(s=>({ title: s.title, seconds: s.minutes }));
    let cursor = new Date(entry.startDate ? entry.startDate.getTime() : Date.now());
    for(const s of segs){ s.start = new Date(cursor.getTime()); s.end = new Date(cursor.getTime() + (s.seconds||0)*1000); cursor = new Date(s.end.getTime()); }
    return segs;
  }

  // Fallback: minute-based defaults
  const segs = DEFAULT_SEGMENTS.map(s=>({ title: s.title, minutes: s.minutes }));
  if(entry.startDate){ let cursor = new Date(entry.startDate.getTime()); for(const s of segs){ s.start = new Date(cursor.getTime()); s.end = new Date(cursor.getTime() + (s.minutes||0)*60*1000); cursor = new Date(s.end.getTime()); } }
  return segs;
}

function renderIdle(nextUpcoming){
  // show idle view, hide judging view
  if(judgingView) judgingView.style.display = 'none';
  if(idleView) idleView.style.display = 'block';
  // clear active judging state and update bottom bar
  activeJudging = null;
  setBottomBarState(false);
  // determine editor visibility so we don't overwrite its intent
  const inEditor = !!(editorView && editorView.style && editorView.style.display && editorView.style.display !== 'none');
  // Disable Start Now when a saved/demo schedule is present (user should use scheduled sessions)
  if(bbStartNow) bbStartNow.disabled = inEditor || !!hasSavedActiveSchedule;
  if(startNowBtn) startNowBtn.disabled = inEditor || !!hasSavedActiveSchedule;
  // basic display
  if(!nextUpcoming){
    console.log('[JT] renderIdle: no upcoming events');
    if(idleClock){ idleClock.style.display='block'; idleClock.style.visibility='visible'; idleClock.style.opacity='1'; idleClock.textContent = '00:00'; }
    if(idleSub) idleSub.textContent = 'No events scheduled';
  } else {
    const secs = Math.max(0, Math.ceil((nextUpcoming.startDate.getTime() - Date.now())/1000));
    console.log('[JT] renderIdle: nextUpcoming', nextUpcoming, 'secs', secs);
    if(idleClock){ idleClock.style.display='block'; idleClock.style.visibility='visible'; idleClock.style.opacity='1'; idleClock.textContent = fmtMS(secs); }
    if(idleSub) idleSub.textContent = `${nextUpcoming.teamName || '(No team)'} — starts at ${nextUpcoming.startTime}`;
  }
}

function renderJudging(current){
  // show judging view, hide idle view
  if(idleView) idleView.style.display = 'none';
  if(judgingView) judgingView.style.display = 'block';
  // set active judging state and update bottom bar to End/Cancel
  activeJudging = current;
  setBottomBarState(true);
  // ensure action buttons are enabled while judging is active
  const inEditor = !!(editorView && editorView.style && editorView.style.display && editorView.style.display !== 'none');
  if(bbStartNow) bbStartNow.disabled = inEditor ? true : false;
  if(startNowBtn) startNowBtn.disabled = inEditor ? true : false;
  // team/slot
  if(judgingTeam) judgingTeam.textContent = current.teamName || '(No team)';
  if(judgingSlot) judgingSlot.textContent = current.slot>=0 ? 'Slot ' + current.slot : '';
  // elapsed
  const now = new Date();
  const start = current.startDate || now;
  const elapsed = Math.floor((now.getTime() - start.getTime())/1000);
  if(judgingElapsed) judgingElapsed.textContent = fmtMS(elapsed);

  // build segments and render statuses
  const segs = getSegmentsForEntry(current);
  if(segmentsList) segmentsList.innerHTML = '';
  for(let i=0;i<segs.length;i++){
    const s = segs[i];
    // ensure start/end available
    if(!s.start || !s.end){
      // if no start/end (no schedule time), compute relative offsets from start
      let offset = 0;
      for(let j=0;j<i;j++) offset += (segs[j].minutes||0)*60*1000;
      s.start = new Date(start.getTime() + offset);
      s.end = new Date(s.start.getTime() + (s.minutes||0)*60*1000);
    }

    let status = 'upcoming';
    if(now.getTime() >= s.end.getTime()) status = 'done';
    else if(now.getTime() >= s.start.getTime() && now.getTime() < s.end.getTime()) status = 'current';

    let labelText = '';
    if(status === 'done'){
      labelText = 'COMPLETE';
    } else if(status === 'current'){
      const remainingSec = Math.max(0, Math.ceil((s.end.getTime() - now.getTime())/1000));
      labelText = fmtMS(remainingSec);
    } else {
      labelText = 'Not started';
    }

    if(segmentsList){
      const div = document.createElement('div');
      // mark the container as current when this segment is active so we can style title + timer together
      div.className = 'segment' + (status === 'current' ? ' current' : '');
       const title = document.createElement('div'); title.className = 'seg-title'; title.textContent = s.title;
       const stat = document.createElement('div'); stat.className = 'seg-status ' + (status==='done'?'done':status==='current'?'current':'upcoming');
       stat.textContent = labelText;
       div.appendChild(title);
       div.appendChild(stat);
       segmentsList.appendChild(div);
    }
  }
}

function updateLoop(){
  tickLocalTime();
  console.log('[JT] updateLoop start', new Date().toISOString(), { manualSession: !!manualSession });
  // use saved schedule
  const sched = loadDaySchedule();
  // compute dates for schedule
  const dates = computeDatesForSchedule(sched);
  // compute whether there are any scheduled entries remaining (current or upcoming) excluding cancelled slots
  const nowMs = Date.now();
  hasSavedActiveSchedule = Array.isArray(dates) && dates.some(d => d && d.startDate && d.judgingEnd && !(typeof d.slot === 'number' && cancelledSlots.has(d.slot)) && d.judgingEnd.getTime() > nowMs);
  const now = Date.now();
  console.log('[JT] schedule entries', (sched && sched.length) || 0, 'computed dates', dates.length);
  // if manual session active
  if(manualSession){
    const startMs = manualSession.startDate.getTime();
    const judgeEndMs = manualSession.judgingEnd.getTime();
    if(now < judgeEndMs){ renderJudging(manualSession); return; }
    manualSession = null; // expired
  }
  // find current scheduled judging
  let current = null;
  for(const d of dates){ if(d.startDate && d.judgingEnd && now >= d.startDate.getTime() && now < d.judgingEnd.getTime()){ current = d; break; } }
  // find next upcoming
  let nextUpcoming = null;
  for(const d of dates){ if(d.startDate && now < d.startDate.getTime()){ nextUpcoming = d; break; } }
  if(current) { renderJudging(current); } else { renderIdle(nextUpcoming); }
}

function startMainInterval(){
  if(intervalId) clearInterval(intervalId);
  console.log('[JT] startMainInterval');
  intervalId = setInterval(updateLoop, 1000);
  updateLoop();
}

// Editor helpers (very small)
function buildEditorRows(){
  editorRows.innerHTML = '';
  const saved = loadDaySchedule();
  for(let i=0;i<MAX_TEAMS;i++){
    const entry = saved.find(s=>s.slot===i) || { slot:i, teamName:'', startTime:'' };
    const row = document.createElement('div'); row.style.display='flex'; row.style.gap='8px'; row.innerHTML = `<input id="day-team-${i}" placeholder="Team name" value="${entry.teamName||''}" /><input id="day-time-${i}" type="time" value="${entry.startTime||''}" />`;
    editorRows.appendChild(row);
  }
}
function collectEditorSchedule(){ const out=[]; for(let i=0;i<MAX_TEAMS;i++){ const team=document.getElementById(`day-team-${i}`); const time=document.getElementById(`day-time-${i}`); out.push({ slot:i, teamName: team?team.value.trim():'', startTime: time?time.value:'' }); } return out; }

// PWA: register service worker using relative path
if('serviceWorker' in navigator){
  navigator.serviceWorker.register('./service-worker.js')
    .then(()=>console.log('[JT] service worker registered'))
    .catch((e)=>console.log('[JT] service worker register failed', e));
}

// Menu toggle behavior: open/close and click-outside to close
const appMenu = document.getElementById('appMenu');
// ensure app menu is hidden on initial load
if(appMenu){ appMenu.style.display = 'none'; appMenu.setAttribute('aria-hidden','true'); }
function toggleMenu(show){
  if(!appMenu) return;
  appMenu.style.display = show ? 'block' : 'none';
  // set ARIA states for accessibility
  try{ appMenu.setAttribute('aria-hidden', show ? 'false' : 'true'); }catch(e){}
  try{ if(menuToggleBtn) menuToggleBtn.setAttribute('aria-expanded', show ? 'true' : 'false'); }catch(e){}
  console.log('[JT] toggleMenu', show);
  if(show){
    const first = appMenu.querySelector('button, [tabindex]');
    if(first) first.focus();
  }
}

const menuToggleBtn = document.getElementById('menuToggle');
const menuCloseBtn = document.getElementById('menuCloseBtn');
if(menuToggleBtn){
  // existing handler kept; also log separately
  menuToggleBtn.addEventListener('click', (e)=>{ console.log('[JT] menuToggleBtn click'); e.stopPropagation(); const isVisible = appMenu && appMenu.style.display === 'block'; toggleMenu(!isVisible); });
}
if(menuCloseBtn){
  menuCloseBtn.addEventListener('click', ()=> toggleMenu(false));
}
// close when clicking outside the menu
document.addEventListener('click', (e)=>{
  if(!appMenu) return;
  const isVisible = appMenu.style.display === 'block';
  if(isVisible && !appMenu.contains(e.target) && menuToggleBtn && !menuToggleBtn.contains(e.target)){
    toggleMenu(false);
  }
});
// also close on Escape
document.addEventListener('keydown', (e)=>{ if(e.key === 'Escape') toggleMenu(false); });

// Menu item bindings
const openEditorBtn2 = document.getElementById('openEditorBtn2');
const saveAsExampleBtn2 = document.getElementById('saveAsExampleBtn2');
const clearSavedBtn2 = document.getElementById('clearSavedBtn2');
const themeToggleBtn2 = document.getElementById('themeToggleBtn2');
const helpBtn = document.getElementById('helpBtn');
const closeHelpBtn = document.getElementById('closeHelpBtn');
const installBtn = document.getElementById('installBtn');

if(openEditorBtn2){ openEditorBtn2.addEventListener('click', ()=>{ if(openEditorBtn) openEditorBtn.click(); toggleMenu(false); }); }

if(saveAsExampleBtn2){ saveAsExampleBtn2.addEventListener('click', ()=>{
  // create an example schedule (8:00 start, sequential)
  const today = new Date();
  const example = [];
  const hhStart = 8;
  for(let i=0;i<MAX_TEAMS;i++){
    const dt = new Date(today.getFullYear(), today.getMonth(), today.getDate(), hhStart, 0, 0, 0);
    dt.setMinutes(dt.getMinutes() + i*(JUDGING_MIN + DISCUSSION_MIN));
    const hh = String(dt.getHours()).padStart(2,'0');
    const mm = String(dt.getMinutes()).padStart(2,'0');
    example.push({ slot:i, teamName:`Team ${i+1}`, startTime:`${hh}:${mm}` });
  }
  saveDaySchedule(example);
  updateLoop();
  toggleMenu(false);
}); }

if(clearSavedBtn2){ clearSavedBtn2.addEventListener('click', ()=>{
  if(!confirm('Clear saved schedule from this browser?')) return; localStorage.removeItem(STORAGE_KEY); updateLoop(); toggleMenu(false);
}); }

// THEME: update label and persist preference
function setThemeButtonLabel(){
  if(!themeToggleBtn2) return;
  const isLight = document.documentElement.classList.contains('light-theme');
  themeToggleBtn2.textContent = isLight ? 'Switch to dark mode' : 'Switch to light mode';
}
function applyStoredTheme(){
  if(localStorage.getItem('lightTheme')==='true'){
    document.documentElement.classList.add('light-theme');
  } else {
    document.documentElement.classList.remove('light-theme');
  }
  setThemeButtonLabel();
}
if(themeToggleBtn2){
  themeToggleBtn2.addEventListener('click', ()=>{
    const isLight = document.documentElement.classList.toggle('light-theme');
    localStorage.setItem('lightTheme', isLight? 'true' : 'false');
    setThemeButtonLabel();
    toggleMenu(false);
  });
}
// apply persisted theme on load and update label
applyStoredTheme();

if(helpBtn){ helpBtn.addEventListener('click', ()=>{ const hm = document.getElementById('helpModal'); if(hm) hm.style.display='flex'; toggleMenu(false); }); }
if(closeHelpBtn){ closeHelpBtn.addEventListener('click', ()=>{ const hm = document.getElementById('helpModal'); if(hm) hm.style.display='none'; }); }

if(installBtn){ installBtn.addEventListener('click', async ()=>{
  if(window.deferredPrompt){ try{ window.deferredPrompt.prompt(); const choice = await window.deferredPrompt.userChoice; window.deferredPrompt = null; }catch(e){} } else { alert('Install not available in this environment.'); }
  toggleMenu(false);
}); }

// start
startMainInterval();

// ensure the edit button reflects current state on load
updateEditButtonState(!!(bbStartNow && bbStartNow.classList.contains('danger')));

// Attach UI listeners safely (guard elements may be missing)
if(openEditorBtn){ openEditorBtn.addEventListener('click', ()=>{ buildEditorRows(); editorView.style.display='block'; }); }
if(idleEditBtn){ idleEditBtn.addEventListener('click', ()=>{ buildEditorRows(); editorView.style.display='block'; }); }
if(saveDayBtn){ saveDayBtn.addEventListener('click', ()=>{ const sched = collectEditorSchedule(); saveDaySchedule(sched); editorView.style.display='none'; updateLoop(); }); }

// open editor from bottom-bar Edit button
if(bbEdit){ bbEdit.addEventListener('click', ()=>{ buildEditorRows(); editorView.style.display = 'block'; }); }

if(cancelDayBtn){ cancelDayBtn.addEventListener('click', ()=>{ if(editorView) editorView.style.display='none'; }); }

if(clearDayBtn){ clearDayBtn.addEventListener('click', ()=>{
  if(!confirm('Clear saved schedule and all editor fields?')) return;
  // clear persisted schedule
  localStorage.removeItem(STORAGE_KEY);
  // clear editor inputs
  for(let i=0;i<MAX_TEAMS;i++){
    const t = document.getElementById(`day-team-${i}`);
    const tm = document.getElementById(`day-time-${i}`);
    if(t) t.value = '';
    if(tm) tm.value = '';
   }
  // hide editor and refresh UI
  if(editorView) editorView.style.display = 'none';
  updateLoop();
}); }

if(startNowBtn){ startNowBtn.addEventListener('click', ()=>{
  const name = prompt('Enter team name for manual start:', 'Manual');
  if(name === null) return; // cancelled
  const now = new Date();
  manualSession = { slot:-1, teamName: name.trim() || 'Manual', startDate: now, judgingEnd: new Date(now.getTime()+JUDGING_MIN*60*1000) };
  updateLoop();
}); }

if(bbStartNow){
  bbStartNow.addEventListener('click', ()=>{
    // If a judging session is active, treat this as End/Cancel
    if(activeJudging || manualSession){
      // end current session
      manualSession = null;
      activeJudging = null;
      updateLoop();
      return;
    }
    // otherwise start a manual judging session
    const name = prompt('Enter team name for manual start:', 'Manual');
    if(name === null) return; // cancelled
    const now = new Date();
    manualSession = { slot:-1, teamName: name.trim() || 'Manual', startDate: now, judgingEnd: new Date(now.getTime()+JUDGING_MIN*60*1000) };
    updateLoop();
  });
}
  </script>
</body>
</html>